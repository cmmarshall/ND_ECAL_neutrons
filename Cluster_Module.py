#!/usr/bin/env python

import sys
import os.path
import os
import ROOT
from optparse import OptionParser
from array import array
from math import sqrt
import subprocess



class Hit:

    def __init__(self, pos, volName, hEnergy, hTime, parent, neutral_tid, parentKE):
        self.pos = pos
        self.volName = volName
        self.hEnergy = hEnergy
        self.hTime = hTime
        self.parent = parent
        self.neutral_tid = neutral_tid
        self.parentKE = parentKE

    def getPos(self):
        return self.pos
    def getVolName(self):
        return self.volName
    def gethEnergy(self):
        return self.hEnergy
    def gethTime(self):
        return self.hTime
    def getParent(self):
        return self.parent
    def getNeutralTID(self):
        return self.neutral_tid
    def getParentKE(self):
        return self.parentKE

class NeutronCandidate:

    def __init__(self, Cluster_Threshold = 5):
        self.intpt = None
        self.inttime = None
        self.hits = []
        self.energy = 0.
        self.cells = {}
        self.nhits = 0
        self.thresh = Cluster_Threshold


        #----Some (Hopefully) Helpful Comments----#
        #Since, we are not clustering by truth, but we want to keep track of "True Parents"
        #what we do is that I wrote a function called GenTruePDG/KE and GenTID
        #Basically, these look at all of the hits in self.hits and figure out the dominant Truth Quantities
        #When you add a hit, these are generated by default so as long as your cluster is not empty, don't worry about it
        #Truth Quantities

        self.aux_PDG = {'g': 0, 'n': 0}
        self.aux_KE = {}
        self.aux_TID = {}
        self.truePDG = -1
        self.trueKE = -1.
        self.tid = -2

    def __add__(self,other): #This is merging clusters
        other_hits = other.getHits(); self_hits = self.getHits()
        if len(other_hits) > self.hits:
            for hit in self_hits:
                other.addHit(hit)
            return other
        else:
            for hit in other_hits:
                self.addHit(hit)
            return self

    def __iadd__(self, other): #Recursively merging clusters

	import time as time
	s_time = time.time()
        other_hits = other.getHits(); self_hits = self.getHits()
	new_obj = NeutronCandidate()
#	print('Stuff is happening')
	for i, hit in enumerate(self_hits):
#	    print('hit %d of %d'%(i, len(self_hits)))
	    new_obj.addHit(hit)
	for i, hit in enumerate(other_hits):
#            print('hit %d of %d'%(i, len(other_hits)))
	    new_obj.addHit(hit)
	return new_obj

	
    """
        if len(other_hits) > len(self_hits):
            for i,hit in enumerate(self_hits):
		print('hit %d of %d'%(i, len(self_hits)))
                other.addHit(hit)
	    print('Total Time:%.2f'%(time.time() - s_time))
            return other
        else:
            for i, hit in enumerate(other_hits):
		print('Hit %d of %d'%(i, len(other_hits)))
                self.addHit(hit)
	    print('Total Time:%.2f'%(time.time() - s_time))
            return self
    """
    def __contains__(self, other):
        hits = self.hits
        for hit in hits:
            diff = hit.getPos() - other.getPos()
        distance = sqrt(diff.Dot(diff))
        if distance <= self.thresh:
            return True
        return False

    def GenTruePDG(self):
        if self.aux_PDG['g'] >= self.aux_PDG['n']:
            self.truePDG = 22
        else:
            self.truePDG = 2112

    def GenTrueKE(self):
        aux_lst = [(val,key) for key,val in self.aux_TID.items()]
        self.trueKE = self.aux_KE[max(aux_lst)[1]]

    def GenTID(self):
        aux_lst = [(val, key) for key,val in self.aux_TID.items()]
        self.tid = max(aux_lst)[1]

    def UpdateTruth(self):
        self.GenTruePDG()
        self.GenTrueKE()
        self.GenTID()

    def addHit(self, hit, GenTruth = False):
        self.nhits += 1
        self.hits.append(hit)
	
	import time as time
	s_time = time.time()
	pos = hit.getPos() 
        volName = hit.getVolName()
        hEnergy = hit.gethEnergy()
        hTime = hit.gethTime()
        parent = hit.getParent()
        neutral_tid = hit.getNeutralTID()
        parentKE = hit.getParentKE()

	time1 = time.time()
#	print('Doing this takes: %.2f'%(time1 - s_time))
        if volName not in self.cells:
            self.cells[volName] = hEnergy
        else:
            self.cells[volName] += hEnergy

        self.energy += hEnergy


	time2 = time.time()
#	print('Doing this other thing takes: %.2f'%(time2 - time1))
        if self.inttime is None:
            self.inttime = hTime
        elif hTime < self.inttime:
            self.inttime = hTime

	time3 = time.time()
#	print('Doing this other other things takes: %.2f'%(time3 - time2))
        if self.intpt is None:
            self.intpt = pos*hEnergy
        else:
            self.intpt += pos*hEnergy # energy-weighted average


	time4 = time.time()
#	print('Now this take: %.2f'%(time4 - time3))
        self.aux_PDG[parent] += hEnergy

        if neutral_tid in self.aux_TID:
            self.aux_TID[neutral_tid] += hEnergy
        else:
            self.aux_TID[neutral_tid] = hEnergy

        if neutral_tid not in self.aux_KE:
            self.aux_KE[neutral_tid] = parentKE


	time5 = time.time()
#	print('Now this takes: %.2f'%(time5 - time4))
        if GenTruth:
            self.GenTruePDG()
            self.GenTrueKE()
            self.GenTID()

    def getHits(self):
        return self.hits

    def getPos(self):
        return (1./self.energy) * self.intpt

    def getTime(self):
        return self.inttime

    def getEnergy(self):
        return self.energy

    def getNcell(self):
        return len(self.cells)

    def getNcellCut(self, cut):
        count = 0
        for c in self.cells:
            if self.cells[c] > cut:
                count += 1
        return count

    def getMaxCell(self):
        m = 0.
        for c in self.cells:
            if self.cells[c] > m:
                m = self.cells[c]
        return m

    def getTruePDG(self):
        return self.truePDG

    def getTrueKE(self):
        return self.trueKE

    def printNC(self):
        print "  Neutron candidate from track ID %d at time %1.1f" % (self.tid, self.inttime)
        print "     %d hits on %d cells, total energy %1.1f MeV, centroid (%1.1f, %1.1f, %1.1f)" % (self.nhits, len(self.cells), self.energy, self.intpt.x()/self.energy, self.intpt.y()/self.energy, self.intpt.z()/self.energy)

def GetPurityData(candidates, No):
    import csv
    output1 = []; output2 = []

#    print('Number of Clusters:%d'%(len(candidates)))
    for cluster in candidates:
        No_of_NParents = 0; No_of_GParents = 0
        #neutral_tids = [];
        hits = cluster.getHits()
        Energy_Dict = {}
        for hit in hits:
            parent = hit.getParent(); edep = hit.gethEnergy()
            neutral_tid = hit.getNeutralTID()
            if parent == 'n':
                No_of_NParents+=edep
            if parent == 'g':
                No_of_GParents+=edep
            if neutral_tid in Energy_Dict:
                Energy_Dict[neutral_tid] += edep
            else:
                Energy_Dict[neutral_tid] = edep

        aux_list = [(value, key) for key, value in Energy_Dict.items()]
        output2.append(float(max(aux_list)[0])/float((No_of_GParents + No_of_NParents)))
        output1.append(float(max(No_of_GParents, No_of_NParents))/float((No_of_GParents + No_of_NParents)))
    with open('./Test/Purity_NvG_%d.csv'%No, 'w') as writeFile:
        writer = csv.writer(writeFile)
        for thing in output1:
            writer.writerow([thing])
    with open('./Test/Purity_ParentTID_%d.csv'%No, 'w') as writeFile:
        writer = csv.writer(writeFile)
        for thing in output2:
            writer.writerow([thing])

def Closest_Cluster_Distribution(candidates,No):
    import csv
    output = []
    for i in range(len(candidates)):
        min_distance = 1e100
        for j in range(len(candidates)):
            if i == j:
                continue
            else:
                clusteri = candidates[i]; clusterj = candidates[j]
                ivec = clusteri.getPos(); jvec = clusterj.getPos()
                diff = ivec - jvec; distance = sqrt(diff.Dot(diff))
                if distance < min_distance:
                    min_distance = distance
        if min_distance != 1e100:
            output.append(min_distance)
    with open('./Test/Distance_Distribution_%d.csv'%No, 'w') as writeFile:
        writer = csv.writer(writeFile)
        for thing in output:
            writer.writerow([thing])




#def isinCluster(candidate, cluster, thresh):
    #candidate should be a T3Vector
    #cluster is a NeutronCandidate object
#    hits = cluster.getHits()
#    for hit in hits:
#        diff = hit.getPos() - candidate
#        distance = sqrt(diff.Dot(diff))
#        if distance <= thresh:
#            return True
#    return False
